Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    TYPE
    ASSIGN_ADD
    COMMAND_RANDOM
    COMMENT
    STRING_LITERAL
    COMMAND_PRINT
    COMP_GTR
    COMP_LESS
    UNKNOWN
    CHAR_LITERAL
    COMP_EQU
    WHITESPACE
    COMP_NEQU
    ASSIGN_DIV
    ID
    BOOL_OR
    BOOL_AND
    ASSIGN_MULT
    COMP_GTE
    ASSIGN_SUB
    COMP_LTE

Grammar

Rule 0     S' -> program
Rule 1     program -> statements
Rule 2     statements -> <empty>
Rule 3     statements -> statements statement
Rule 4     statement -> expression ;
Rule 5     expression -> <empty>
Rule 6     expression -> VAL_LITERAL
Rule 7     expression -> expression + expression
Rule 8     expression -> expression - expression
Rule 9     expression -> expression * expression
Rule 10    expression -> expression / expression

Terminals, with rules where they appear

*                    : 9
+                    : 7
-                    : 8
/                    : 10
;                    : 4
ASSIGN_ADD           : 
ASSIGN_DIV           : 
ASSIGN_MULT          : 
ASSIGN_SUB           : 
BOOL_AND             : 
BOOL_OR              : 
CHAR_LITERAL         : 
COMMAND_PRINT        : 
COMMAND_RANDOM       : 
COMMENT              : 
COMP_EQU             : 
COMP_GTE             : 
COMP_GTR             : 
COMP_LESS            : 
COMP_LTE             : 
COMP_NEQU            : 
ID                   : 
STRING_LITERAL       : 
TYPE                 : 
UNKNOWN              : 
VAL_LITERAL          : 6
WHITESPACE           : 
error                : 

Nonterminals, with rules where they appear

expression           : 4 7 7 8 8 9 9 10 10
program              : 0
statement            : 3
statements           : 1 3

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statements
    (2) statements -> .
    (3) statements -> . statements statement

    VAL_LITERAL     reduce using rule 2 (statements -> .)
    ;               reduce using rule 2 (statements -> .)
    +               reduce using rule 2 (statements -> .)
    -               reduce using rule 2 (statements -> .)
    *               reduce using rule 2 (statements -> .)
    /               reduce using rule 2 (statements -> .)
    $end            reduce using rule 2 (statements -> .)

    statements                     shift and go to state 1
    program                        shift and go to state 2

state 1

    (1) program -> statements .
    (3) statements -> statements . statement
    (4) statement -> . expression ;
    (5) expression -> .
    (6) expression -> . VAL_LITERAL
    (7) expression -> . expression + expression
    (8) expression -> . expression - expression
    (9) expression -> . expression * expression
    (10) expression -> . expression / expression

    $end            reduce using rule 1 (program -> statements .)
    ;               reduce using rule 5 (expression -> .)
    +               reduce using rule 5 (expression -> .)
    -               reduce using rule 5 (expression -> .)
    *               reduce using rule 5 (expression -> .)
    /               reduce using rule 5 (expression -> .)
    VAL_LITERAL     shift and go to state 5

    statement                      shift and go to state 3
    expression                     shift and go to state 4

state 2

    (0) S' -> program .



state 3

    (3) statements -> statements statement .

    VAL_LITERAL     reduce using rule 3 (statements -> statements statement .)
    ;               reduce using rule 3 (statements -> statements statement .)
    +               reduce using rule 3 (statements -> statements statement .)
    -               reduce using rule 3 (statements -> statements statement .)
    *               reduce using rule 3 (statements -> statements statement .)
    /               reduce using rule 3 (statements -> statements statement .)
    $end            reduce using rule 3 (statements -> statements statement .)


state 4

    (4) statement -> expression . ;
    (7) expression -> expression . + expression
    (8) expression -> expression . - expression
    (9) expression -> expression . * expression
    (10) expression -> expression . / expression

    ;               shift and go to state 7
    +               shift and go to state 9
    -               shift and go to state 6
    *               shift and go to state 10
    /               shift and go to state 8


state 5

    (6) expression -> VAL_LITERAL .

    ;               reduce using rule 6 (expression -> VAL_LITERAL .)
    +               reduce using rule 6 (expression -> VAL_LITERAL .)
    -               reduce using rule 6 (expression -> VAL_LITERAL .)
    *               reduce using rule 6 (expression -> VAL_LITERAL .)
    /               reduce using rule 6 (expression -> VAL_LITERAL .)


state 6

    (8) expression -> expression - . expression
    (5) expression -> .
    (6) expression -> . VAL_LITERAL
    (7) expression -> . expression + expression
    (8) expression -> . expression - expression
    (9) expression -> . expression * expression
    (10) expression -> . expression / expression

    +               reduce using rule 5 (expression -> .)
    -               reduce using rule 5 (expression -> .)
    *               reduce using rule 5 (expression -> .)
    /               reduce using rule 5 (expression -> .)
    ;               reduce using rule 5 (expression -> .)
    VAL_LITERAL     shift and go to state 5

    expression                     shift and go to state 11

state 7

    (4) statement -> expression ; .

    VAL_LITERAL     reduce using rule 4 (statement -> expression ; .)
    ;               reduce using rule 4 (statement -> expression ; .)
    +               reduce using rule 4 (statement -> expression ; .)
    -               reduce using rule 4 (statement -> expression ; .)
    *               reduce using rule 4 (statement -> expression ; .)
    /               reduce using rule 4 (statement -> expression ; .)
    $end            reduce using rule 4 (statement -> expression ; .)


state 8

    (10) expression -> expression / . expression
    (5) expression -> .
    (6) expression -> . VAL_LITERAL
    (7) expression -> . expression + expression
    (8) expression -> . expression - expression
    (9) expression -> . expression * expression
    (10) expression -> . expression / expression

    +               reduce using rule 5 (expression -> .)
    -               reduce using rule 5 (expression -> .)
    *               reduce using rule 5 (expression -> .)
    /               reduce using rule 5 (expression -> .)
    ;               reduce using rule 5 (expression -> .)
    VAL_LITERAL     shift and go to state 5

    expression                     shift and go to state 12

state 9

    (7) expression -> expression + . expression
    (5) expression -> .
    (6) expression -> . VAL_LITERAL
    (7) expression -> . expression + expression
    (8) expression -> . expression - expression
    (9) expression -> . expression * expression
    (10) expression -> . expression / expression

    +               reduce using rule 5 (expression -> .)
    -               reduce using rule 5 (expression -> .)
    *               reduce using rule 5 (expression -> .)
    /               reduce using rule 5 (expression -> .)
    ;               reduce using rule 5 (expression -> .)
    VAL_LITERAL     shift and go to state 5

    expression                     shift and go to state 13

state 10

    (9) expression -> expression * . expression
    (5) expression -> .
    (6) expression -> . VAL_LITERAL
    (7) expression -> . expression + expression
    (8) expression -> . expression - expression
    (9) expression -> . expression * expression
    (10) expression -> . expression / expression

    +               reduce using rule 5 (expression -> .)
    -               reduce using rule 5 (expression -> .)
    *               reduce using rule 5 (expression -> .)
    /               reduce using rule 5 (expression -> .)
    ;               reduce using rule 5 (expression -> .)
    VAL_LITERAL     shift and go to state 5

    expression                     shift and go to state 14

state 11

    (8) expression -> expression - expression .
    (7) expression -> expression . + expression
    (8) expression -> expression . - expression
    (9) expression -> expression . * expression
    (10) expression -> expression . / expression

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
    ;               reduce using rule 8 (expression -> expression - expression .)
    +               shift and go to state 9
    -               shift and go to state 6
    *               shift and go to state 10
    /               shift and go to state 8

  ! +               [ reduce using rule 8 (expression -> expression - expression .) ]
  ! -               [ reduce using rule 8 (expression -> expression - expression .) ]
  ! *               [ reduce using rule 8 (expression -> expression - expression .) ]
  ! /               [ reduce using rule 8 (expression -> expression - expression .) ]


state 12

    (10) expression -> expression / expression .
    (7) expression -> expression . + expression
    (8) expression -> expression . - expression
    (9) expression -> expression . * expression
    (10) expression -> expression . / expression

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
    ;               reduce using rule 10 (expression -> expression / expression .)
    +               shift and go to state 9
    -               shift and go to state 6
    *               shift and go to state 10
    /               shift and go to state 8

  ! +               [ reduce using rule 10 (expression -> expression / expression .) ]
  ! -               [ reduce using rule 10 (expression -> expression / expression .) ]
  ! *               [ reduce using rule 10 (expression -> expression / expression .) ]
  ! /               [ reduce using rule 10 (expression -> expression / expression .) ]


state 13

    (7) expression -> expression + expression .
    (7) expression -> expression . + expression
    (8) expression -> expression . - expression
    (9) expression -> expression . * expression
    (10) expression -> expression . / expression

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
    ;               reduce using rule 7 (expression -> expression + expression .)
    +               shift and go to state 9
    -               shift and go to state 6
    *               shift and go to state 10
    /               shift and go to state 8

  ! +               [ reduce using rule 7 (expression -> expression + expression .) ]
  ! -               [ reduce using rule 7 (expression -> expression + expression .) ]
  ! *               [ reduce using rule 7 (expression -> expression + expression .) ]
  ! /               [ reduce using rule 7 (expression -> expression + expression .) ]


state 14

    (9) expression -> expression * expression .
    (7) expression -> expression . + expression
    (8) expression -> expression . - expression
    (9) expression -> expression . * expression
    (10) expression -> expression . / expression

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
    ;               reduce using rule 9 (expression -> expression * expression .)
    +               shift and go to state 9
    -               shift and go to state 6
    *               shift and go to state 10
    /               shift and go to state 8

  ! +               [ reduce using rule 9 (expression -> expression * expression .) ]
  ! -               [ reduce using rule 9 (expression -> expression * expression .) ]
  ! *               [ reduce using rule 9 (expression -> expression * expression .) ]
  ! /               [ reduce using rule 9 (expression -> expression * expression .) ]

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for + in state 11 resolved as shift
WARNING: shift/reduce conflict for - in state 11 resolved as shift
WARNING: shift/reduce conflict for * in state 11 resolved as shift
WARNING: shift/reduce conflict for / in state 11 resolved as shift
WARNING: shift/reduce conflict for + in state 12 resolved as shift
WARNING: shift/reduce conflict for - in state 12 resolved as shift
WARNING: shift/reduce conflict for * in state 12 resolved as shift
WARNING: shift/reduce conflict for / in state 12 resolved as shift
WARNING: shift/reduce conflict for + in state 13 resolved as shift
WARNING: shift/reduce conflict for - in state 13 resolved as shift
WARNING: shift/reduce conflict for * in state 13 resolved as shift
WARNING: shift/reduce conflict for / in state 13 resolved as shift
WARNING: shift/reduce conflict for + in state 14 resolved as shift
WARNING: shift/reduce conflict for - in state 14 resolved as shift
WARNING: shift/reduce conflict for * in state 14 resolved as shift
WARNING: shift/reduce conflict for / in state 14 resolved as shift
